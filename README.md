# OpenWeatherMap

Веб-сервис для анализа исторических температурных данных и мониторинга текущей погоды с использованием OpenWeatherMap API.

Для работы с файлами установите вирутальное окружение и все необходимые пакеты:

```
python3.11 -m venv venv_p3.11_open_weather_map

source ./venv_p3.11_open_weather_map/bin/activate

pip install -r requirements.txt

jupyter lab
```

## Основные возможности
1. Анализ исторических температурных данных

- Визуализация временных рядов температуры

- Выявление температурных аномалий

- Анализ сезонных паттернов

- Скользящее среднее и доверительные интервалы

2. Мониторинг текущей погоды

- Получение актуальных данных о погоде через OpenWeatherMap API

- Сравнение текущей температуры с историческими нормами

- Поддержка нескольких городов

3. Сравнение производительности

- Параллельная vs последовательная обработка данных (Polars vs Pandas)

- Синхронные vs асинхронные запросы


---

`Polars` — это современная библиотека для обработки данных, которая написана на **Rust**, известном своей высокой производительностью. Она спроектирована для работы с данными в колонковом формате, аналогично базам данных OLAP (Online Analytical Processing).

**Основные принципы работы**

1. **Поколоночное хранение данных (Columnar Storage)**
   - В отличие от `pandas`, где данные хранятся в строковом формате, `Polars` организует данные в **поколоночном формате**.
   - Это позволяет эффективно использовать кэш процессора, так как операции над данными выполняются над целыми колонками, а не строками.

2. **Многопоточность**
   - `Polars` активно использует многопоточность для выполнения операций. Это позволяет эффективно использовать все доступные ядра процессора.
   - Например, если нужно выполнить операцию над всей колонкой, `Polars` разбивает её на части и обрабатывает их параллельно.

3. **Память на уровне языка Rust**
   - Rust обеспечивает безопасность работы с памятью и низкий уровень накладных расходов.
   - Благодаря Rust, `Polars` может эффективно управлять ресурсами, минимизируя выделение и освобождение памяти.

4. **Оптимизированные вычисления**
   - Использует векторизированные вычисления, где операции выполняются сразу над блоками данных.
   - Пример: вместо того чтобы проходить по колонке элемент за элементом, `Polars` выполняет операцию над группами элементов, используя SIMD (Single Instruction, Multiple Data).

#### Пример оптимизации в `Polars`:
- Для выполнения операции, такой как `(col1 * col2) + col3`, `Polars` создает **физический план выполнения**. Этот план оптимизируется, чтобы минимизировать количество операций.
- Пример: если `col1` и `col2` уже загружены в кэш, их произведение выполняется быстрее.

---

## Сравнительный анализ при локальном запуске:
При увеличении датафрейма в 100 раз получил следующие результаты измерения последовательной и параллельной обработки:
 - Время последовательной обработки 0.09698 сек
 - Время параллельной обработки 0.02173 сек
 - Разница 0.07524 сек

 При запуске теста API-запросов получил следующие результаты:
 - Время синхронного запроса для всех городов: 0.78 сек/город
 - Среднее время синхронного запроса: 0.16 сек/город
 - Время асинхронного запроса для всех городов: 0.16 сек
 - Среднее время на город: 0.03 сек

 ## Основные вывода:
 1. За счет многопоточности `Polars` было достигнуто ускорение вычислительных процессов. Время обработки сократилось примерно в 4,5 раза.
 2. Используя асинхронность мы получили информацию по всем городам за такое же время как в синхронном режиме по одному городу.
